<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ollama Chat</title>
  <link rel="stylesheet" href="styles.css">
  <script defer src="alpine.min.js"></script>
</head>
<body>
  <div class="app" x-data="chatApp()">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-header">
        <h2>Ollama Chat</h2>
      </div>
      
      <!-- Model Selector -->
      <div class="model-selector">
        <label>Model</label>
        <select x-model="selectedModel" :disabled="loading">
          <template x-if="models.length === 0">
            <option>Loading models...</option>
          </template>
          <template x-for="model in models" :key="model">
            <option :value="model" x-text="model"></option>
          </template>
        </select>
      </div>
      
      <!-- Status -->
      <div class="status" :class="ollamaStatus ? 'online' : 'offline'">
        <span class="status-dot"></span>
        <span x-text="ollamaStatus ? 'Ollama Online' : 'Ollama Offline'"></span>
      </div>
      
      <!-- New Chat Button -->
      <button class="new-chat-btn" @click="newChat()">
        + New Chat
      </button>
      
      <!-- Chat History -->
      <div class="chat-history">
        <template x-for="(chat, index) in chatHistory" :key="index">
          <div class="chat-item" :class="currentChatIndex === index ? 'active' : ''" @click="loadChat(index)">
            <span x-text="chat.title || 'New Chat'"></span>
          </div>
        </template>
      </div>
    </div>
    
    <!-- Main Chat Area -->
    <div class="chat-main">
      <!-- Messages -->
      <div class="messages" x-ref="messagesContainer">
        <template x-if="messages.length === 0 && !loading">
          <div class="empty-state">
            <h3>Start a conversation</h3>
            <p>Select a model and type a message to begin</p>
          </div>
        </template>
        
        <template x-for="(msg, index) in messages" :key="index">
          <div class="message" :class="msg.role">
            <!-- Thinking Block (collapsible) -->
            <template x-if="msg.thinking">
              <div class="thinking-block">
                <div class="thinking-header" @click="msg.showThinking = !msg.showThinking">
                  <span>ðŸ§  Reasoning</span>
                  <span x-text="msg.showThinking ? 'â–¼' : 'â–¶'"></span>
                </div>
                <div class="thinking-content" x-show="msg.showThinking" x-html="formatMessage(msg.thinking)"></div>
              </div>
            </template>
            
            <!-- Message Content -->
            <div class="message-content" x-html="formatMessage(msg.content)"></div>
          </div>
        </template>
        
        <!-- Live Streaming Message -->
        <template x-if="loading && (streamingThinking || streamingMessage)">
          <div class="message assistant streaming">
            <!-- Live Thinking Block -->
            <template x-if="streamingThinking">
              <div class="thinking-block live">
                <div class="thinking-header">
                  <span>ðŸ§  Thinking<span class="thinking-dots">...</span></span>
                  <div class="thinking-indicator"></div>
                </div>
                <div class="thinking-content" x-html="formatMessage(streamingThinking)">
                </div>
              </div>
            </template>
            
            <!-- Live Content -->
            <template x-if="streamingMessage">
              <div class="message-content">
                <span x-html="formatMessage(streamingMessage)"></span><span class="cursor">â–Š</span>
              </div>
            </template>
          </div>
        </template>
        
        <!-- Loading indicator (before any streaming) -->
        <template x-if="loading && !streamingThinking && !streamingMessage">
          <div class="message assistant">
            <div class="message-content loading">
              <span class="dot"></span>
              <span class="dot"></span>
              <span class="dot"></span>
            </div>
          </div>
        </template>
      </div>
      
      <!-- Input Area -->
      <div class="input-area">
        <textarea 
          x-model="input" 
          @keydown.enter.prevent="!$event.shiftKey && sendMessage()"
          placeholder="Type a message... (Shift+Enter for new line)"
          :disabled="loading || !ollamaStatus"
          x-ref="inputField"
        ></textarea>
        <button @click="sendMessage()" :disabled="loading || !input.trim() || !ollamaStatus">
          <span x-text="loading ? 'Generating...' : 'Send'"></span>
        </button>
      </div>
    </div>
  </div>

  <script>
    function chatApp() {
      return {
        ollamaStatus: false,
        models: [],
        selectedModel: '',
        messages: [],
        input: '',
        loading: false,
        chatHistory: [],
        currentChatIndex: 0,
        
        // Streaming state
        streamingMessage: '',
        streamingThinking: '',
        streamSessionId: null,
        _initialized: false,
        _pollTimeout: null,
        
        async init() {
          if (this._initialized) return;
          this._initialized = true;
          
          await this.checkOllama();
          
          setInterval(() => {
            if (!this.loading) {
              this.checkOllama();
            }
          }, 10000);
        },
        
        async checkOllama() {
          try {
            const wasOnline = this.ollamaStatus;
            this.ollamaStatus = await poly.invoke('check_ollama', {});
            
            if (this.ollamaStatus && !wasOnline) {
              await this.loadModels();
            }
          } catch (e) {
            this.ollamaStatus = false;
          }
        },
        
        async loadModels() {
          try {
            const newModels = await poly.invoke('list_models', {});
            
            if (JSON.stringify(newModels) !== JSON.stringify(this.models)) {
              this.models = newModels;
              if (this.models.length > 0 && !this.selectedModel) {
                this.selectedModel = this.models[0];
              }
            }
          } catch (e) {
            console.error('Failed to load models:', e);
          }
        },
        
        async sendMessage() {
          if (!this.input.trim() || this.loading || this.streamSessionId) return;
          
          this.loading = true;
          
          const userMessage = this.input.trim();
          this.input = '';
          this.streamingMessage = '';
          this.streamingThinking = '';
          this.streamSessionId = null;
          
          // Add user message
          this.messages.push({
            role: 'user',
            content: userMessage
          });
          
          // Update chat title
          if (this.messages.length === 1) {
            this.chatHistory[this.currentChatIndex] = {
              title: userMessage.substring(0, 30) + (userMessage.length > 30 ? '...' : ''),
              messages: [...this.messages]
            };
          }
          
          this.scrollToBottom();
          
          // Build messages for API
          const apiMessages = this.messages.map(m => ({
            role: m.role,
            content: m.content
          }));
          
          try {
            // Start streaming
            const startResult = await poly.invoke('chat_stream_start', {
              model: this.selectedModel,
              messages: apiMessages,
              temperature: 0.7
            });
            
            this.streamSessionId = startResult.session_id;
            
            // Start polling
            this.pollStream();
            
          } catch (e) {
            this.messages.push({
              role: 'assistant',
              content: `Error: ${e.message || e}`
            });
            this.loading = false;
            this.streamSessionId = null;
          }
        },
        
        async pollStream() {
          if (!this.streamSessionId) return;
          
          try {
            const result = await poly.invoke('chat_stream_poll', {
              session_id: this.streamSessionId
            });
            
            // Append thinking (comes first from Ollama)
            if (result.thinking) {
              this.streamingThinking += result.thinking;
              this.scrollToBottom();
            }
            
            // Append content (final answer)
            if (result.content) {
              this.streamingMessage += result.content;
              this.scrollToBottom();
            }
            
            // Check for errors
            if (result.error && result.error !== 'none' && result.error !== null) {
              this.finishStream(`Error: ${result.error}`);
              return;
            }
            
            // Check if done
            if (result.done) {
              this.finishStream();
              return;
            }
            
            // Continue polling quickly for smooth streaming
            this._pollTimeout = setTimeout(() => this.pollStream(), 30);
            
          } catch (e) {
            console.error('Poll error:', e);
            this.finishStream(`Error: ${e.message || e}`);
          }
        },
        
        finishStream(error = null) {
          // Clear timeout
          if (this._pollTimeout) {
            clearTimeout(this._pollTimeout);
            this._pollTimeout = null;
          }
          
          // Close the stream session
          if (this.streamSessionId) {
            poly.invoke('chat_stream_close', { session_id: this.streamSessionId }).catch(() => {});
            this.streamSessionId = null;
          }
          
          // Add final message
          if (error) {
            this.messages.push({
              role: 'assistant',
              content: error
            });
          } else {
            this.messages.push({
              role: 'assistant',
              content: this.streamingMessage || 'No response',
              thinking: this.streamingThinking || null,
              showThinking: false
            });
          }
          
          // Save to history
          if (this.chatHistory[this.currentChatIndex]) {
            this.chatHistory[this.currentChatIndex].messages = [...this.messages];
          }
          
          // Reset streaming state
          this.streamingMessage = '';
          this.streamingThinking = '';
          this.loading = false;
          this.scrollToBottom();
          this.$refs.inputField?.focus();
        },
        
        newChat() {
          this.messages = [];
          this.chatHistory.push({ title: 'New Chat', messages: [] });
          this.currentChatIndex = this.chatHistory.length - 1;
        },
        
        loadChat(index) {
          this.currentChatIndex = index;
          this.messages = [...(this.chatHistory[index].messages || [])];
          this.scrollToBottom();
        },
        
        scrollToBottom() {
          this.$nextTick(() => {
            const container = this.$refs.messagesContainer;
            if (container) {
              container.scrollTop = container.scrollHeight;
            }
          });
        },
        
        formatMessage(content) {
          if (!content) return '';
          return content
            .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            .replace(/\n/g, '<br>');
        }
      };
    }
  </script>
</body>
</html>
